<!DOCTYPE html>
<html>
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

        <!-- Standard Meta -->
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

        <!-- Site Properities -->
        <title>时聆心语 - C++基础</title>

        <link rel="stylesheet" type="text/css" href="../../../../assets/semantic.min.css">
        <link rel="stylesheet" type="text/css" href="../../../../assets/site.css">
		    <link rel="stylesheet" type="text/css" href="../../../../assets/ch-pygments.css">
		    <link rel="stylesheet" type="text/css" href="../../../../assets/readtheorg_smpl.css">
    </head>

    <body id="gh-site" class="pushable">
        <div class="ui vertical inverted sidebar menu right" id="_dst_toc_">
        </div>
        <div class="pusher">
            <!-- Global Header -->
            <div class="page header">
                <div class="ui main container">
                    <div class="ui borderless menu">
                        <a href="../../../../" class="item"><img src="../../../../favicon.ico"></a>
                        <a href="../../../../archives" class="item">Archives</a>
                        <a href="../../../../tags" class="item">Tags</a>
                        <a href="../../../../about" class="item">About</a>
                    </div>
                </div>
            </div>
            <div class="ui hidden divider"></div>
            <div class="page content" data-iframe-height>
                <div class="ui main container">
                    
<div class="ui piled segments">
    <div class="ui segment">
        <div class="ui tiny header">
            <h1>C++基础</h1>
        </div>
    </div>
    <div class="ui blue segment">
        <div class="ui basic grey label">Posted at:<div class="detail">March 6, 2018</div>
</div>
        <div class="tags">
<div class="ui teal tag label">Tags:</div>
<a class="ui basic label" href="../../../../tags/cpp">CPP</a>
</div>
        <div class="ui hidden divider"></div>
        <article>
            <nav id="_SRC_TOC_" style="display:none">
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B"><span class="toc-section-number">1</span> 简介</a></li>
<li><a href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-section-number">2</span> 头文件</a></li>
<li><a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-section-number">3</span> 命名空间</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-section-number">4</span> 输入/输出</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-section-number">5</span> 字符串</a></li>
<li><a href="#%E5%BC%95%E7%94%A8"><span class="toc-section-number">6</span> 引用</a></li>
<li>
<a href="#%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-section-number">7</span> 类与面向对象编程</a><ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-section-number">7.1</span> 初始化与运算符重载</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF"><span class="toc-section-number">7.2</span> 继承</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E6%9D%BF"><span class="toc-section-number">8</span> 模板</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-section-number">9</span> 异常处理</a></li>
<li><a href="#raii"><span class="toc-section-number">10</span> RAII</a></li>
<li>
<a href="#%E6%9D%82%E9%A1%B9misc"><span class="toc-section-number">11</span> 杂项Misc</a><ul>
<li><a href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-section-number">11.1</span> 函数重载</a></li>
<li><a href="#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E8%AE%BE%E7%BD%AE"><span class="toc-section-number">11.2</span> 参数默认值设置</a></li>
<li><a href="#%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-section-number">11.3</span> 空指针</a></li>
<li><a href="#%E4%B8%A5%E6%A0%BC%E5%8E%9F%E5%9E%8B"><span class="toc-section-number">11.4</span> 严格原型</a></li>
</ul>
</li>
<li><a href="#c%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-section-number">12</span> C++新特性</a></li>
<li><a href="#stl"><span class="toc-section-number">13</span> STL</a></li>
</ul>
</nav>
<h1 id="简介">
<span class="header-section-number">1</span> 简介</h1>
<p>本文主要参考 <a href="https://learnxinyminutes.com/docs/c%2B%2B/">Learn X in Y minutes</a> 上的教程介绍C++相关的基础知识。<br>
</p>
<p>相对于C语言，C++具有以下特点：<br>
</p>
<ul>
<li>支持数据的抽象与封装</li>
<li>支持面向对象编程</li>
<li>支持泛型编程</li>
</ul>
<h1 id="头文件">
<span class="header-section-number">2</span> 头文件</h1>
<p>C语言的标准库头文件可以在C++中使用，方法是加上"c"前缀、去掉.h后缀。<br>
C++标准库的头文件使用时也不需要指定后缀，比如说iostream。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a></code></pre></div>
<h1 id="命名空间">
<span class="header-section-number">3</span> 命名空间</h1>
<p>C++引入了命名空间(namespace)概念，为变量、函数、类等提供隔离的作用域，防止命名冲突。<br>
通过namespace关键字可以定义命名空间(允许嵌套)。<br>
</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">namespace</span> MyMod {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="kw">namespace</span> MySubMod {</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">        <span class="dt">void</span> foo()</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">        {</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">            printf(<span class="st">"This is MyMod::MySubMod::foo</span><span class="sc">\n</span><span class="st">"</span>);</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">        }</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    } <span class="co">// end nested namespace MySubMod</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">} <span class="co">// end namespace MyMod</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="dt">void</span> foo()</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    printf(<span class="st">"This is global foo</span><span class="sc">\n</span><span class="st">"</span>);</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">}</a>
<a class="sourceLine" id="cb2-14" data-line-number="14"></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">{</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">    MyMod::MySubMod::foo();</a>
<a class="sourceLine" id="cb2-18" data-line-number="18"></a>
<a class="sourceLine" id="cb2-19" data-line-number="19">    ::foo(); <span class="co">// using global namespace</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">    foo();</a>
<a class="sourceLine" id="cb2-21" data-line-number="21">}</a></code></pre></div>
<p>通过using namespace可以引入指定命名空间内所有symbol，比如说std命名空间。<br>
</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">using</span> <span class="kw">namespace</span> std;</a></code></pre></div>
<p>又或者只引入某个symbol：<br>
</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>cout;</a></code></pre></div>
<h1 id="输入输出">
<span class="header-section-number">4</span> 输入/输出</h1>
<p>C++使用“流”来输入输出。<br>
通过&lt;&lt;插入数据到流中。<br>
通过&gt;&gt;从流中提取数据。<br>
cin、cout、和cerr分别对应stdin(标准输入)、stdout(标准输出)和stderr(标准错误)。<br>
</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span><span class="pp"> </span><span class="co">// 引入输入/输出流的头文件</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">using</span> <span class="kw">namespace</span> std; <span class="co">// 引入std命名空间中的符号，包括cin、cout等</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">   <span class="dt">int</span> myInt;</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">   <span class="co">// 在标准输出中显示</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">   cout &lt;&lt; <span class="st">"Enter your favorite number:</span><span class="sc">\n</span><span class="st">"</span>;</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">   <span class="co">// 从标准输入取值</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">   cin &gt;&gt; myInt;</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">   <span class="co">// 显示“Your favorite number is &lt;myInt&gt;”</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">   cout &lt;&lt; <span class="st">"Your favorite number is "</span> &lt;&lt; myInt &lt;&lt; endl;</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">}</a></code></pre></div>
<p>如果需要实现类似于printf这样控制宽度、精度、对齐、进制(base)的效果，有两种选择：</p>
<ul>
<li>引入cstdio头文件使用printf函数</li>
<li>通过 <a href="http://www.cplusplus.com/reference/ios/ios_base/"><code>ios_base类</code></a> 进行设置</li>
</ul>
<h1 id="字符串">
<span class="header-section-number">5</span> 字符串</h1>
<p>C++中的字符串是string类，提供比char *更好的封装与功能。<br>
可以使用+或者+=拼接字符串(通过运算符重载实现)。<br>
<code>to_string</code> 可以将常见类型转换为string类型。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">using</span> <span class="kw">namespace</span> std; <span class="co">// std::string</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">string strHello = <span class="st">"Hello"</span>;</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">string strWorld = <span class="st">" World"</span>;</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">cout &lt;&lt; strHello + strWorld; <span class="co">// "Hello World"</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">cout &lt;&lt; strHello + <span class="st">" You"</span>;</a></code></pre></div>
<p>对于非英文字符串应该使用wstring存储，比如说中文。<br>
string虽然也可以存储，但实际上是以char作为字符单元，类似计算长度、反转等操作结果并不正确。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    wcout.imbue(locale(<span class="st">"zh_CN.UTF-8"</span>));</a>
<a class="sourceLine" id="cb7-4" data-line-number="4"></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    wstring zhHello = <span class="st">L"你好吗？"</span>;</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    wcout &lt;&lt; zhHello &lt;&lt; <span class="st">L" 长度： "</span> &lt;&lt; to_wstring(zhHello.size()) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">    <span class="co">// 显示 "你好吗？ 长度： 4"</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    reverse(zhHello.begin(), zhHello.end());</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">    wcout &lt;&lt; zhHello &lt;&lt; endl;</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">    <span class="co">// 显示 "？吗好你"</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13"></a>
<a class="sourceLine" id="cb7-14" data-line-number="14">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">}</a></code></pre></div>
<h1 id="引用">
<span class="header-section-number">6</span> 引用</h1>
<p>C++提供引用来设置变量别名，本质上是特殊的指针，初始化后不能重新赋值。<br>
使用引用时的语法与原变量相同：不需要通过*解引用。<br>
常量引用不允许改变变量的值。<br>
</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" data-line-number="1">string foo = <span class="st">"I am foo"</span>;</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">string bar = <span class="st">"I am bar"</span>;</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">string&amp; fooRef = foo; <span class="co">// 建立了一个对foo的引用。</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">fooRef += <span class="st">". Hi!"</span>; <span class="co">// 通过引用来修改foo的值</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">cout &lt;&lt; fooRef; <span class="co">// "I am foo. Hi!"</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="at">const</span> string&amp; barRef = bar; <span class="co">// 建立指向bar的常量引用。</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="co">// 和C语言中一样，（指针和引用）声明为常量时，对应的值不能被修改。</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">barRef += <span class="st">". Hi!"</span>; <span class="co">// 这是错误的，不能修改一个常量引用的值。</span></a></code></pre></div>
<p>对于临时对象的常量引用会使其生命周期延长到当前作用域。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" data-line-number="1">string tempObjectFun() { ... }</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">string retVal = tempObjectFun();</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="co">// 第二行代码实际上做了以下操作：</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="co">//   - tempObjectFun返回一个string对象</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="co">//   - 以返回的对象为参数调用构造函数生成新的string对象</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="co">//   - 销毁返回的对象</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="co">// 返回的对象就是临时对象。</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="co">// 临时对象在函数返回对象的时候创建，在表达式求值结束时销毁(编译器可能会优化)</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">foo(bar(tempObjectFun()))</a>
<a class="sourceLine" id="cb9-11" data-line-number="11"></a>
<a class="sourceLine" id="cb9-12" data-line-number="12"><span class="co">// 假设foo和bar都存在，tempObjectFun返回的对象传递给了bar并在foo调用前销毁</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13"><span class="co">// 在表达式求值结束时销毁临时对象的原则有一个例外的情况：</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14"><span class="co">// 当临时对象绑定到常量引用时，该临时对象的生命周期会延长到当前作用域。</span></a>
<a class="sourceLine" id="cb9-15" data-line-number="15"></a>
<a class="sourceLine" id="cb9-16" data-line-number="16"><span class="dt">void</span> constReferenceTempObjectFun() {</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">  <span class="co">// constRef绑定了返回的临时对象，该对象在本函数范围内仍然有效。</span></a>
<a class="sourceLine" id="cb9-18" data-line-number="18">  <span class="at">const</span> string&amp; constRef = tempObjectFun();</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">  ...</a>
<a class="sourceLine" id="cb9-20" data-line-number="20">}</a></code></pre></div>
<p>另外还有右值引用，因为超出本文范围，建议自行了解。</p>
<h1 id="类与面向对象编程">
<span class="header-section-number">7</span> 类与面向对象编程</h1>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="co">// 声明一个类。</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="co">// 类通常在头文件（.h或.hpp）中声明。</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">class</span> Dog {</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    <span class="co">// 成员变量和成员函数默认情况下是私有（private）的。</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    <span class="bu">std::</span>string name;</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    <span class="dt">int</span> weight;</a>
<a class="sourceLine" id="cb10-9" data-line-number="9"></a>
<a class="sourceLine" id="cb10-10" data-line-number="10"><span class="co">// 在这个标签之后，所有声明都是公有（public）的，</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"><span class="co">// 直到重新指定“private:”（私有继承）或“protected:”（保护继承）为止</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb10-13" data-line-number="13"></a>
<a class="sourceLine" id="cb10-14" data-line-number="14">    <span class="co">// 默认的构造器</span></a>
<a class="sourceLine" id="cb10-15" data-line-number="15">    Dog();</a>
<a class="sourceLine" id="cb10-16" data-line-number="16"></a>
<a class="sourceLine" id="cb10-17" data-line-number="17">    <span class="co">// 这里是成员函数声明的一个例子。</span></a>
<a class="sourceLine" id="cb10-18" data-line-number="18">    <span class="co">// 可以注意到，我们在此处使用了std::string，而不是using namespace std</span></a>
<a class="sourceLine" id="cb10-19" data-line-number="19">    <span class="co">// 语句using namespace绝不应当出现在头文件当中。</span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20">    <span class="dt">void</span> setName(<span class="at">const</span> <span class="bu">std::</span>string&amp; dogsName);</a>
<a class="sourceLine" id="cb10-21" data-line-number="21"></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">    <span class="dt">void</span> setWeight(<span class="dt">int</span> dogsWeight);</a>
<a class="sourceLine" id="cb10-23" data-line-number="23"></a>
<a class="sourceLine" id="cb10-24" data-line-number="24">    <span class="co">// 如果一个函数不对对象的状态进行修改，</span></a>
<a class="sourceLine" id="cb10-25" data-line-number="25">    <span class="co">// 应当在声明中加上const。</span></a>
<a class="sourceLine" id="cb10-26" data-line-number="26">    <span class="co">// 这样，你就可以对一个以常量方式引用的对象执行该操作。</span></a>
<a class="sourceLine" id="cb10-27" data-line-number="27">    <span class="co">// 同时可以注意到，当父类的成员函数需要被子类重写时，</span></a>
<a class="sourceLine" id="cb10-28" data-line-number="28">    <span class="co">// 父类中的函数必须被显式声明为虚函数（virtual）。</span></a>
<a class="sourceLine" id="cb10-29" data-line-number="29">    <span class="co">// 考虑到性能方面的因素，函数默认情况下不会被声明为虚函数。</span></a>
<a class="sourceLine" id="cb10-30" data-line-number="30">    <span class="kw">virtual</span> <span class="dt">void</span> print() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb10-31" data-line-number="31"></a>
<a class="sourceLine" id="cb10-32" data-line-number="32">    <span class="co">// 函数也可以在class body内部定义。</span></a>
<a class="sourceLine" id="cb10-33" data-line-number="33">    <span class="co">// 这样定义的函数会自动成为内联函数。</span></a>
<a class="sourceLine" id="cb10-34" data-line-number="34">    <span class="dt">void</span> bark() <span class="at">const</span> { <span class="bu">std::</span>cout &lt;&lt; name &lt;&lt; <span class="st">" barks!</span><span class="sc">\n</span><span class="st">"</span> }</a>
<a class="sourceLine" id="cb10-35" data-line-number="35"></a>
<a class="sourceLine" id="cb10-36" data-line-number="36">    <span class="co">// 除了构造器以外，C++还提供了析构器。</span></a>
<a class="sourceLine" id="cb10-37" data-line-number="37">    <span class="co">// 当一个对象被删除或者脱离其定义域时，它的析构函数会被调用。</span></a>
<a class="sourceLine" id="cb10-38" data-line-number="38">    <span class="co">// 这使得RAII这样的强大范式（参见下文）成为可能。</span></a>
<a class="sourceLine" id="cb10-39" data-line-number="39">    <span class="co">// 为了衍生出子类来，基类的析构函数必须定义为虚函数。</span></a>
<a class="sourceLine" id="cb10-40" data-line-number="40">    <span class="co">// 如果没有定义为虚函数，那么通过基类引用或者指针销毁时，衍生类的析构函数并不会被调用。</span></a>
<a class="sourceLine" id="cb10-41" data-line-number="41">    <span class="kw">virtual</span> ~Dog();</a>
<a class="sourceLine" id="cb10-42" data-line-number="42"></a>
<a class="sourceLine" id="cb10-43" data-line-number="43">}; <span class="co">// 在类的定义之后，要加一个分号</span></a>
<a class="sourceLine" id="cb10-44" data-line-number="44"></a>
<a class="sourceLine" id="cb10-45" data-line-number="45"><span class="co">// 类的成员函数通常在.cpp文件中实现。</span></a>
<a class="sourceLine" id="cb10-46" data-line-number="46"><span class="dt">void</span> Dog::Dog()</a>
<a class="sourceLine" id="cb10-47" data-line-number="47">{</a>
<a class="sourceLine" id="cb10-48" data-line-number="48">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">"A dog has been constructed</span><span class="sc">\n</span><span class="st">"</span>;</a>
<a class="sourceLine" id="cb10-49" data-line-number="49">}</a>
<a class="sourceLine" id="cb10-50" data-line-number="50"></a>
<a class="sourceLine" id="cb10-51" data-line-number="51"><span class="co">// 复杂对象（例如字符串）应当以引用的形式传递，</span></a>
<a class="sourceLine" id="cb10-52" data-line-number="52"><span class="co">// 对于不需要修改的对象，最好使用常量引用。</span></a>
<a class="sourceLine" id="cb10-53" data-line-number="53"><span class="dt">void</span> Dog::setName(<span class="at">const</span> <span class="bu">std::</span>string&amp; dogsName)</a>
<a class="sourceLine" id="cb10-54" data-line-number="54">{</a>
<a class="sourceLine" id="cb10-55" data-line-number="55">    name = dogsName;</a>
<a class="sourceLine" id="cb10-56" data-line-number="56">}</a>
<a class="sourceLine" id="cb10-57" data-line-number="57"></a>
<a class="sourceLine" id="cb10-58" data-line-number="58"><span class="dt">void</span> Dog::setWeight(<span class="dt">int</span> dogsWeight)</a>
<a class="sourceLine" id="cb10-59" data-line-number="59">{</a>
<a class="sourceLine" id="cb10-60" data-line-number="60">    weight = dogsWeight;</a>
<a class="sourceLine" id="cb10-61" data-line-number="61">}</a>
<a class="sourceLine" id="cb10-62" data-line-number="62"></a>
<a class="sourceLine" id="cb10-63" data-line-number="63"><span class="co">// 虚函数的virtual关键字只需要在声明时使用，不需要在定义时重复</span></a>
<a class="sourceLine" id="cb10-64" data-line-number="64"><span class="dt">void</span> Dog::print() <span class="at">const</span></a>
<a class="sourceLine" id="cb10-65" data-line-number="65">{</a>
<a class="sourceLine" id="cb10-66" data-line-number="66">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">"Dog is "</span> &lt;&lt; name &lt;&lt; <span class="st">" and weighs "</span> &lt;&lt; weight &lt;&lt; <span class="st">"kg</span><span class="sc">\n</span><span class="st">"</span>;</a>
<a class="sourceLine" id="cb10-67" data-line-number="67">}</a>
<a class="sourceLine" id="cb10-68" data-line-number="68"></a>
<a class="sourceLine" id="cb10-69" data-line-number="69"><span class="dt">void</span> Dog::~Dog()</a>
<a class="sourceLine" id="cb10-70" data-line-number="70">{</a>
<a class="sourceLine" id="cb10-71" data-line-number="71">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">"Goodbye "</span> &lt;&lt; name &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>;</a>
<a class="sourceLine" id="cb10-72" data-line-number="72">}</a>
<a class="sourceLine" id="cb10-73" data-line-number="73"></a>
<a class="sourceLine" id="cb10-74" data-line-number="74"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb10-75" data-line-number="75">    Dog myDog; <span class="co">// 此时显示“A dog has been constructed”</span></a>
<a class="sourceLine" id="cb10-76" data-line-number="76">    myDog.setName(<span class="st">"Barkley"</span>);</a>
<a class="sourceLine" id="cb10-77" data-line-number="77">    myDog.setWeight(<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb10-78" data-line-number="78">    myDog.print(); <span class="co">// 显示“Dog is Barkley and weighs 10 kg”</span></a>
<a class="sourceLine" id="cb10-79" data-line-number="79">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-80" data-line-number="80">} <span class="co">// 显示“Goodbye Barkley”</span></a></code></pre></div>
<h2 id="初始化与运算符重载">
<span class="header-section-number">7.1</span> 初始化与运算符重载</h2>
<p>变量可以直接赋初值，也可以在初始化列表中根据外部参数赋值。<br>
另外C++允许运算符重载，也就是改变运算符（比如说+，*）对于对象的行为。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="kw">using</span> <span class="kw">namespace</span> std;</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">class</span> Point {</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">    <span class="co">// 可以以这样的方式为成员变量设置默认值。</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">    <span class="dt">double</span> x = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">    <span class="dt">double</span> y = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb11-9" data-line-number="9"></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">    <span class="co">// 定义一个默认的构造器。</span></a>
<a class="sourceLine" id="cb11-11" data-line-number="11">    <span class="co">// 除了将Point初始化为(0, 0)以外，这个函数什么都不做。</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">    Point() { };</a>
<a class="sourceLine" id="cb11-13" data-line-number="13"></a>
<a class="sourceLine" id="cb11-14" data-line-number="14">    <span class="co">// 下面使用的语法称为初始化列表，</span></a>
<a class="sourceLine" id="cb11-15" data-line-number="15">    <span class="co">// 这是初始化类中成员变量的正确方式。</span></a>
<a class="sourceLine" id="cb11-16" data-line-number="16">    Point (<span class="dt">double</span> a, <span class="dt">double</span> b) :</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">        x(a),</a>
<a class="sourceLine" id="cb11-18" data-line-number="18">        y(b)</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">    { <span class="co">/* 除了初始化成员变量外，什么都不做 */</span> }</a>
<a class="sourceLine" id="cb11-20" data-line-number="20"></a>
<a class="sourceLine" id="cb11-21" data-line-number="21">    <span class="co">// 重载 + 运算符</span></a>
<a class="sourceLine" id="cb11-22" data-line-number="22">    Point <span class="kw">operator</span>+(<span class="at">const</span> Point&amp; rhs) <span class="at">const</span>;</a>
<a class="sourceLine" id="cb11-23" data-line-number="23"></a>
<a class="sourceLine" id="cb11-24" data-line-number="24">    <span class="co">// 重载 += 运算符</span></a>
<a class="sourceLine" id="cb11-25" data-line-number="25">    Point&amp; <span class="kw">operator</span>+=(<span class="at">const</span> Point&amp; rhs);</a>
<a class="sourceLine" id="cb11-26" data-line-number="26"></a>
<a class="sourceLine" id="cb11-27" data-line-number="27">    <span class="co">// 增加 - 和 -= 运算符也是有意义的，但这里不再赘述。</span></a>
<a class="sourceLine" id="cb11-28" data-line-number="28">};</a>
<a class="sourceLine" id="cb11-29" data-line-number="29"></a>
<a class="sourceLine" id="cb11-30" data-line-number="30">Point Point::<span class="kw">operator</span>+(<span class="at">const</span> Point&amp; rhs) <span class="at">const</span></a>
<a class="sourceLine" id="cb11-31" data-line-number="31">{</a>
<a class="sourceLine" id="cb11-32" data-line-number="32">    <span class="co">// 创建一个新的点，</span></a>
<a class="sourceLine" id="cb11-33" data-line-number="33">    <span class="co">// 其横纵坐标分别为这个点与另一点在对应方向上的坐标之和。</span></a>
<a class="sourceLine" id="cb11-34" data-line-number="34">    <span class="cf">return</span> Point(x + rhs.x, y + rhs.y);</a>
<a class="sourceLine" id="cb11-35" data-line-number="35">}</a>
<a class="sourceLine" id="cb11-36" data-line-number="36"></a>
<a class="sourceLine" id="cb11-37" data-line-number="37">Point&amp; Point::<span class="kw">operator</span>+=(<span class="at">const</span> Point&amp; rhs)</a>
<a class="sourceLine" id="cb11-38" data-line-number="38">{</a>
<a class="sourceLine" id="cb11-39" data-line-number="39">    x += rhs.x;</a>
<a class="sourceLine" id="cb11-40" data-line-number="40">    y += rhs.y;</a>
<a class="sourceLine" id="cb11-41" data-line-number="41">    <span class="cf">return</span> *<span class="kw">this</span>;</a>
<a class="sourceLine" id="cb11-42" data-line-number="42">}</a>
<a class="sourceLine" id="cb11-43" data-line-number="43"></a>
<a class="sourceLine" id="cb11-44" data-line-number="44"><span class="dt">int</span> main () {</a>
<a class="sourceLine" id="cb11-45" data-line-number="45">    Point up (<span class="dv">0</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb11-46" data-line-number="46">    Point right (<span class="dv">1</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb11-47" data-line-number="47">    <span class="co">// 这里使用了Point类型的运算符“+”</span></a>
<a class="sourceLine" id="cb11-48" data-line-number="48">    <span class="co">// 调用up（Point类型）的“+”方法，并以right作为函数的参数</span></a>
<a class="sourceLine" id="cb11-49" data-line-number="49">    Point result = up + right;</a>
<a class="sourceLine" id="cb11-50" data-line-number="50">    <span class="co">// 显示“Result is upright (1,1)”</span></a>
<a class="sourceLine" id="cb11-51" data-line-number="51">    cout &lt;&lt; <span class="st">"Result is upright ("</span> &lt;&lt; result.x &lt;&lt; <span class="ch">','</span> &lt;&lt; result.y &lt;&lt; <span class="st">")</span><span class="sc">\n</span><span class="st">"</span>;</a>
<a class="sourceLine" id="cb11-52" data-line-number="52">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb11-53" data-line-number="53">}</a></code></pre></div>
<h2 id="继承">
<span class="header-section-number">7.2</span> 继承</h2>
<p>继承可以复用已有代码，可以分为单继承、多继承、虚拟继承。<br>
利用多态可以提高灵活性、增加可维护性。<br>
除了继承外，合理使用组合也是不错的选择。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="co">// 这个类继承了Dog类中的公有（public）和保护（protected）内容，</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="co">// 私有（private）内容实际上也继承了，但是只能通过public或者protected方法进行访问</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="kw">class</span> OwnedDog : <span class="kw">public</span> Dog {</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    <span class="dt">void</span> setOwner(<span class="at">const</span> <span class="bu">std::</span>string&amp; dogsOwner)</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    <span class="co">// 重写OwnedDogs类的print方法。</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">    <span class="co">// 如果你不熟悉子类多态的话，可以参考这个页面中的概述：</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    <span class="co">// http://zh.wikipedia.org/wiki/%E5%AD%90%E7%B1%BB%E5%9E%8B</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10"></a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    <span class="co">// override关键字是可选的，它确保你所重写的是基类中的方法。</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">    <span class="dt">void</span> print() <span class="at">const</span> <span class="kw">override</span>;</a>
<a class="sourceLine" id="cb12-13" data-line-number="13"></a>
<a class="sourceLine" id="cb12-14" data-line-number="14"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb12-15" data-line-number="15">    <span class="bu">std::</span>string owner;</a>
<a class="sourceLine" id="cb12-16" data-line-number="16">};</a>
<a class="sourceLine" id="cb12-17" data-line-number="17"></a>
<a class="sourceLine" id="cb12-18" data-line-number="18"><span class="co">// 与此同时，在对应的.cpp文件里：</span></a>
<a class="sourceLine" id="cb12-19" data-line-number="19"></a>
<a class="sourceLine" id="cb12-20" data-line-number="20"><span class="dt">void</span> OwnedDog::setOwner(<span class="at">const</span> <span class="bu">std::</span>string&amp; dogsOwner)</a>
<a class="sourceLine" id="cb12-21" data-line-number="21">{</a>
<a class="sourceLine" id="cb12-22" data-line-number="22">    owner = dogsOwner;</a>
<a class="sourceLine" id="cb12-23" data-line-number="23">}</a>
<a class="sourceLine" id="cb12-24" data-line-number="24"></a>
<a class="sourceLine" id="cb12-25" data-line-number="25"><span class="dt">void</span> OwnedDog::print() <span class="at">const</span></a>
<a class="sourceLine" id="cb12-26" data-line-number="26">{</a>
<a class="sourceLine" id="cb12-27" data-line-number="27">    Dog::print(); <span class="co">// 调用基类Dog中的print方法</span></a>
<a class="sourceLine" id="cb12-28" data-line-number="28">    <span class="co">// "Dog is &lt;name&gt; and weights &lt;weight&gt;"</span></a>
<a class="sourceLine" id="cb12-29" data-line-number="29"></a>
<a class="sourceLine" id="cb12-30" data-line-number="30">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">"Dog is owned by "</span> &lt;&lt; owner &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>;</a>
<a class="sourceLine" id="cb12-31" data-line-number="31">    <span class="co">// "Dog is owned by &lt;owner&gt;"</span></a>
<a class="sourceLine" id="cb12-32" data-line-number="32">}</a></code></pre></div>
<h1 id="模板">
<span class="header-section-number">8</span> 模板</h1>
<p>C++模板主要用于泛型编程。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="kw">class</span> Box {</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    <span class="co">// In this class, T can be used as any other type.</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    <span class="dt">void</span> insert(<span class="at">const</span> T&amp;) { ... }</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">};</a>
<a class="sourceLine" id="cb13-7" data-line-number="7"></a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="co">// During compilation, the compiler actually generates copies of each template</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="co">// with parameters substituted, so the full definition of the class must be</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10"><span class="co">// present at each invocation. This is why you will see template classes defined</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11"><span class="co">// entirely in header files.</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12"></a>
<a class="sourceLine" id="cb13-13" data-line-number="13"><span class="co">// To instantiate a template class on the stack:</span></a>
<a class="sourceLine" id="cb13-14" data-line-number="14">Box&lt;<span class="dt">int</span>&gt; intBox;</a>
<a class="sourceLine" id="cb13-15" data-line-number="15"></a>
<a class="sourceLine" id="cb13-16" data-line-number="16"><span class="co">// and you can use it as you would expect:</span></a>
<a class="sourceLine" id="cb13-17" data-line-number="17">intBox.insert(<span class="dv">123</span>);</a>
<a class="sourceLine" id="cb13-18" data-line-number="18"></a>
<a class="sourceLine" id="cb13-19" data-line-number="19"><span class="co">// You can, of course, nest templates:</span></a>
<a class="sourceLine" id="cb13-20" data-line-number="20">Box&lt;Box&lt;<span class="dt">int</span>&gt; &gt; boxOfBox;</a>
<a class="sourceLine" id="cb13-21" data-line-number="21">boxOfBox.insert(intBox);</a>
<a class="sourceLine" id="cb13-22" data-line-number="22"></a>
<a class="sourceLine" id="cb13-23" data-line-number="23"><span class="co">// Until C++11, you had to place a space between the two '&gt;'s, otherwise '&gt;&gt;'</span></a>
<a class="sourceLine" id="cb13-24" data-line-number="24"><span class="co">// would be parsed as the right shift operator.</span></a>
<a class="sourceLine" id="cb13-25" data-line-number="25"></a>
<a class="sourceLine" id="cb13-26" data-line-number="26"><span class="co">// You will sometimes see</span></a>
<a class="sourceLine" id="cb13-27" data-line-number="27"><span class="co">//   template&lt;typename T&gt;</span></a>
<a class="sourceLine" id="cb13-28" data-line-number="28"><span class="co">// instead. The 'class' keyword and 'typename' keywords are _mostly_</span></a>
<a class="sourceLine" id="cb13-29" data-line-number="29"><span class="co">// interchangeable in this case. For the full explanation, see</span></a>
<a class="sourceLine" id="cb13-30" data-line-number="30"><span class="co">//   http://en.wikipedia.org/wiki/Typename</span></a>
<a class="sourceLine" id="cb13-31" data-line-number="31"><span class="co">// (yes, that keyword has its own Wikipedia page).</span></a>
<a class="sourceLine" id="cb13-32" data-line-number="32"></a>
<a class="sourceLine" id="cb13-33" data-line-number="33"><span class="co">// Similarly, a template function:</span></a>
<a class="sourceLine" id="cb13-34" data-line-number="34"><span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;</a>
<a class="sourceLine" id="cb13-35" data-line-number="35"><span class="dt">void</span> barkThreeTimes(<span class="at">const</span> T&amp; input)</a>
<a class="sourceLine" id="cb13-36" data-line-number="36">{</a>
<a class="sourceLine" id="cb13-37" data-line-number="37">    input.bark();</a>
<a class="sourceLine" id="cb13-38" data-line-number="38">    input.bark();</a>
<a class="sourceLine" id="cb13-39" data-line-number="39">    input.bark();</a>
<a class="sourceLine" id="cb13-40" data-line-number="40">}</a>
<a class="sourceLine" id="cb13-41" data-line-number="41"></a>
<a class="sourceLine" id="cb13-42" data-line-number="42"><span class="co">// Notice that nothing is specified about the type parameters here. The compiler</span></a>
<a class="sourceLine" id="cb13-43" data-line-number="43"><span class="co">// will generate and then type-check every invocation of the template, so the</span></a>
<a class="sourceLine" id="cb13-44" data-line-number="44"><span class="co">// above function works with any type 'T' that has a const 'bark' method!</span></a>
<a class="sourceLine" id="cb13-45" data-line-number="45"></a>
<a class="sourceLine" id="cb13-46" data-line-number="46">Dog fluffy;</a>
<a class="sourceLine" id="cb13-47" data-line-number="47">fluffy.setName(<span class="st">"Fluffy"</span>)</a>
<a class="sourceLine" id="cb13-48" data-line-number="48">barkThreeTimes(fluffy); <span class="co">// Prints "Fluffy barks" three times.</span></a>
<a class="sourceLine" id="cb13-49" data-line-number="49"></a>
<a class="sourceLine" id="cb13-50" data-line-number="50"><span class="co">// Template parameters don't have to be classes:</span></a>
<a class="sourceLine" id="cb13-51" data-line-number="51"><span class="kw">template</span>&lt;<span class="dt">int</span> Y&gt;</a>
<a class="sourceLine" id="cb13-52" data-line-number="52"><span class="dt">void</span> printMessage() {</a>
<a class="sourceLine" id="cb13-53" data-line-number="53">  cout &lt;&lt; <span class="st">"Learn C++ in "</span> &lt;&lt; Y &lt;&lt; <span class="st">" minutes!"</span> &lt;&lt; endl;</a>
<a class="sourceLine" id="cb13-54" data-line-number="54">}</a>
<a class="sourceLine" id="cb13-55" data-line-number="55"></a>
<a class="sourceLine" id="cb13-56" data-line-number="56"><span class="co">// And you can explicitly specialize templates for more efficient code. Of</span></a>
<a class="sourceLine" id="cb13-57" data-line-number="57"><span class="co">// course, most real-world uses of specialization are not as trivial as this.</span></a>
<a class="sourceLine" id="cb13-58" data-line-number="58"><span class="co">// Note that you still need to declare the function (or class) as a template</span></a>
<a class="sourceLine" id="cb13-59" data-line-number="59"><span class="co">// even if you explicitly specified all parameters.</span></a>
<a class="sourceLine" id="cb13-60" data-line-number="60"><span class="kw">template</span>&lt;&gt;</a>
<a class="sourceLine" id="cb13-61" data-line-number="61"><span class="dt">void</span> printMessage&lt;<span class="dv">10</span>&gt;() {</a>
<a class="sourceLine" id="cb13-62" data-line-number="62">  cout &lt;&lt; <span class="st">"Learn C++ faster in only 10 minutes!"</span> &lt;&lt; endl;</a>
<a class="sourceLine" id="cb13-63" data-line-number="63">}</a>
<a class="sourceLine" id="cb13-64" data-line-number="64"></a>
<a class="sourceLine" id="cb13-65" data-line-number="65">printMessage&lt;<span class="dv">20</span>&gt;();  <span class="co">// Prints "Learn C++ in 20 minutes!"</span></a>
<a class="sourceLine" id="cb13-66" data-line-number="66">printMessage&lt;<span class="dv">10</span>&gt;();  <span class="co">// Prints "Learn C++ faster in only 10 minutes!"</span></a></code></pre></div>
<h1 id="异常处理">
<span class="header-section-number">9</span> 异常处理</h1>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="co">// 在try代码块中拋出的异常可以被随后的catch捕获。</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="cf">try</span> {</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    <span class="co">// 不要用 new关键字在堆上为异常分配空间。</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    <span class="cf">throw</span> <span class="bu">std::</span>exception(<span class="st">"A problem occurred"</span>);</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="co">// 如果拋出的异常是一个对象，可以用常量引用来捕获它</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="cf">catch</span> (<span class="at">const</span> <span class="bu">std::</span>exception&amp; ex)</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">  <span class="bu">std::</span>cout &lt;&lt; ex.what();</a>
<a class="sourceLine" id="cb14-10" data-line-number="10"><span class="co">// 捕获尚未被catch处理的所有错误</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb14-12" data-line-number="12"><span class="cf">catch</span> (...)</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">{</a>
<a class="sourceLine" id="cb14-14" data-line-number="14">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">"Unknown exception caught"</span>;</a>
<a class="sourceLine" id="cb14-15" data-line-number="15">    <span class="cf">throw</span>; <span class="co">// 重新拋出异常</span></a>
<a class="sourceLine" id="cb14-16" data-line-number="16">}</a>
<a class="sourceLine" id="cb14-17" data-line-number="17"></a></code></pre></div>
<h1 id="raii">
<span class="header-section-number">10</span> RAII</h1>
<p>RAII指的是“资源获取就是初始化”（Resource Allocation Is Initialization）。<br>
RAII是C++中最强大的编程范式之一。<br>
简单来说，就是在构造函数中申请资源，在析构函数中释放资源。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="dt">void</span> doSomethingWithAFile(<span class="at">const</span> <span class="dt">char</span>* filename)</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="co">// 首先，让我们假设一切都会顺利进行。</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    <span class="dt">FILE</span>* fh = fopen(filename, <span class="st">"r"</span>); <span class="co">// 以只读模式打开文件</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">    doSomethingWithTheFile(fh);</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">    doSomethingElseWithIt(fh);</a>
<a class="sourceLine" id="cb15-9" data-line-number="9"></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    fclose(fh); <span class="co">// 关闭文件句柄</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb15-12" data-line-number="12"></a>
<a class="sourceLine" id="cb15-13" data-line-number="13"><span class="co">// 不幸的是，随着错误处理机制的引入，事情会变得复杂。</span></a>
<a class="sourceLine" id="cb15-14" data-line-number="14"><span class="co">// 假设fopen函数有可能执行失败，</span></a>
<a class="sourceLine" id="cb15-15" data-line-number="15"><span class="co">// 而doSomethingWithTheFile和doSomethingElseWithIt会在失败时返回错误代码。</span></a>
<a class="sourceLine" id="cb15-16" data-line-number="16"><span class="co">// （虽然异常是C++中处理错误的推荐方式，</span></a>
<a class="sourceLine" id="cb15-17" data-line-number="17"><span class="co">// 但是某些程序员，尤其是有C语言背景的，并不认可异常捕获机制的作用）。</span></a>
<a class="sourceLine" id="cb15-18" data-line-number="18"><span class="co">// 现在，我们必须检查每个函数调用是否成功执行，并在问题发生的时候关闭文件句柄。</span></a>
<a class="sourceLine" id="cb15-19" data-line-number="19"><span class="dt">bool</span> doSomethingWithAFile(<span class="at">const</span> <span class="dt">char</span>* filename)</a>
<a class="sourceLine" id="cb15-20" data-line-number="20">{</a>
<a class="sourceLine" id="cb15-21" data-line-number="21">    <span class="dt">FILE</span>* fh = fopen(filename, <span class="st">"r"</span>); <span class="co">// 以只读模式打开文件</span></a>
<a class="sourceLine" id="cb15-22" data-line-number="22">    <span class="cf">if</span> (fh == <span class="kw">nullptr</span>) <span class="co">// 当执行失败是，返回的指针是nullptr</span></a>
<a class="sourceLine" id="cb15-23" data-line-number="23">        <span class="cf">return</span> <span class="kw">false</span>; <span class="co">// 向调用者汇报错误</span></a>
<a class="sourceLine" id="cb15-24" data-line-number="24"></a>
<a class="sourceLine" id="cb15-25" data-line-number="25">    <span class="co">// 假设每个函数会在执行失败时返回false</span></a>
<a class="sourceLine" id="cb15-26" data-line-number="26">    <span class="cf">if</span> (!doSomethingWithTheFile(fh)) {</a>
<a class="sourceLine" id="cb15-27" data-line-number="27">        fclose(fh); <span class="co">// 关闭文件句柄，避免造成内存泄漏。</span></a>
<a class="sourceLine" id="cb15-28" data-line-number="28">        <span class="cf">return</span> <span class="kw">false</span>; <span class="co">// 反馈错误</span></a>
<a class="sourceLine" id="cb15-29" data-line-number="29">    }</a>
<a class="sourceLine" id="cb15-30" data-line-number="30">    <span class="cf">if</span> (!doSomethingElseWithIt(fh)) {</a>
<a class="sourceLine" id="cb15-31" data-line-number="31">        fclose(fh); <span class="co">// 关闭文件句柄</span></a>
<a class="sourceLine" id="cb15-32" data-line-number="32">        <span class="cf">return</span> <span class="kw">false</span>; <span class="co">// 反馈错误</span></a>
<a class="sourceLine" id="cb15-33" data-line-number="33">    }</a>
<a class="sourceLine" id="cb15-34" data-line-number="34"></a>
<a class="sourceLine" id="cb15-35" data-line-number="35">    fclose(fh); <span class="co">// 关闭文件句柄</span></a>
<a class="sourceLine" id="cb15-36" data-line-number="36">    <span class="cf">return</span> <span class="kw">true</span>; <span class="co">// 指示函数已成功执行</span></a>
<a class="sourceLine" id="cb15-37" data-line-number="37">}</a>
<a class="sourceLine" id="cb15-38" data-line-number="38"></a>
<a class="sourceLine" id="cb15-39" data-line-number="39"><span class="co">// C语言的程序员通常会借助goto语句简化上面的代码：</span></a>
<a class="sourceLine" id="cb15-40" data-line-number="40"><span class="dt">bool</span> doSomethingWithAFile(<span class="at">const</span> <span class="dt">char</span>* filename)</a>
<a class="sourceLine" id="cb15-41" data-line-number="41">{</a>
<a class="sourceLine" id="cb15-42" data-line-number="42">    <span class="dt">FILE</span>* fh = fopen(filename, <span class="st">"r"</span>);</a>
<a class="sourceLine" id="cb15-43" data-line-number="43">    <span class="cf">if</span> (fh == <span class="kw">nullptr</span>)</a>
<a class="sourceLine" id="cb15-44" data-line-number="44">        <span class="cf">return</span> <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb15-45" data-line-number="45"></a>
<a class="sourceLine" id="cb15-46" data-line-number="46">    <span class="cf">if</span> (!doSomethingWithTheFile(fh))</a>
<a class="sourceLine" id="cb15-47" data-line-number="47">        <span class="cf">goto</span> failure;</a>
<a class="sourceLine" id="cb15-48" data-line-number="48"></a>
<a class="sourceLine" id="cb15-49" data-line-number="49">    <span class="cf">if</span> (!doSomethingElseWithIt(fh))</a>
<a class="sourceLine" id="cb15-50" data-line-number="50">        <span class="cf">goto</span> failure;</a>
<a class="sourceLine" id="cb15-51" data-line-number="51"></a>
<a class="sourceLine" id="cb15-52" data-line-number="52">    fclose(fh); <span class="co">// 关闭文件</span></a>
<a class="sourceLine" id="cb15-53" data-line-number="53">    <span class="cf">return</span> <span class="kw">true</span>; <span class="co">// 执行成功</span></a>
<a class="sourceLine" id="cb15-54" data-line-number="54"></a>
<a class="sourceLine" id="cb15-55" data-line-number="55">failure:</a>
<a class="sourceLine" id="cb15-56" data-line-number="56">    fclose(fh);</a>
<a class="sourceLine" id="cb15-57" data-line-number="57">    <span class="cf">return</span> <span class="kw">false</span>; <span class="co">// 反馈错误</span></a>
<a class="sourceLine" id="cb15-58" data-line-number="58">}</a>
<a class="sourceLine" id="cb15-59" data-line-number="59"></a>
<a class="sourceLine" id="cb15-60" data-line-number="60"><span class="co">// 如果用异常捕获机制来指示错误的话，</span></a>
<a class="sourceLine" id="cb15-61" data-line-number="61"><span class="co">// 代码会变得清晰一些，但是仍然有优化的余地。</span></a>
<a class="sourceLine" id="cb15-62" data-line-number="62"><span class="dt">void</span> doSomethingWithAFile(<span class="at">const</span> <span class="dt">char</span>* filename)</a>
<a class="sourceLine" id="cb15-63" data-line-number="63">{</a>
<a class="sourceLine" id="cb15-64" data-line-number="64">    <span class="dt">FILE</span>* fh = fopen(filename, <span class="st">"r"</span>); <span class="co">// 以只读模式打开文件</span></a>
<a class="sourceLine" id="cb15-65" data-line-number="65">    <span class="cf">if</span> (fh == <span class="kw">nullptr</span>)</a>
<a class="sourceLine" id="cb15-66" data-line-number="66">        <span class="cf">throw</span> <span class="bu">std::</span>exception(<span class="st">"Could not open the file."</span>);</a>
<a class="sourceLine" id="cb15-67" data-line-number="67"></a>
<a class="sourceLine" id="cb15-68" data-line-number="68">    <span class="cf">try</span> {</a>
<a class="sourceLine" id="cb15-69" data-line-number="69">        doSomethingWithTheFile(fh);</a>
<a class="sourceLine" id="cb15-70" data-line-number="70">        doSomethingElseWithIt(fh);</a>
<a class="sourceLine" id="cb15-71" data-line-number="71">    }</a>
<a class="sourceLine" id="cb15-72" data-line-number="72">    <span class="cf">catch</span> (...) {</a>
<a class="sourceLine" id="cb15-73" data-line-number="73">        fclose(fh); <span class="co">// 保证出错的时候文件被正确关闭</span></a>
<a class="sourceLine" id="cb15-74" data-line-number="74">        <span class="cf">throw</span>; <span class="co">// 之后，重新抛出这个异常</span></a>
<a class="sourceLine" id="cb15-75" data-line-number="75">    }</a>
<a class="sourceLine" id="cb15-76" data-line-number="76"></a>
<a class="sourceLine" id="cb15-77" data-line-number="77">    fclose(fh); <span class="co">// 关闭文件</span></a>
<a class="sourceLine" id="cb15-78" data-line-number="78">    <span class="co">// 所有工作顺利完成</span></a>
<a class="sourceLine" id="cb15-79" data-line-number="79">}</a>
<a class="sourceLine" id="cb15-80" data-line-number="80"></a>
<a class="sourceLine" id="cb15-81" data-line-number="81"><span class="co">// 相比之下，使用C++中的文件流类（fstream）时，</span></a>
<a class="sourceLine" id="cb15-82" data-line-number="82"><span class="co">// fstream会利用自己的析构器来关闭文件句柄。</span></a>
<a class="sourceLine" id="cb15-83" data-line-number="83"><span class="co">// 只要离开了某一对象的定义域，它的析构函数就会被自动调用。</span></a>
<a class="sourceLine" id="cb15-84" data-line-number="84"><span class="dt">void</span> doSomethingWithAFile(<span class="at">const</span> <span class="bu">std::</span>string&amp; filename)</a>
<a class="sourceLine" id="cb15-85" data-line-number="85">{</a>
<a class="sourceLine" id="cb15-86" data-line-number="86">    <span class="co">// ifstream是输入文件流（input file stream）的简称</span></a>
<a class="sourceLine" id="cb15-87" data-line-number="87">    <span class="bu">std::</span>ifstream fh(filename); <span class="co">// 打开一个文件</span></a>
<a class="sourceLine" id="cb15-88" data-line-number="88"></a>
<a class="sourceLine" id="cb15-89" data-line-number="89">    <span class="co">// 对文件进行一些操作</span></a>
<a class="sourceLine" id="cb15-90" data-line-number="90">    doSomethingWithTheFile(fh);</a>
<a class="sourceLine" id="cb15-91" data-line-number="91">    doSomethingElseWithIt(fh);</a>
<a class="sourceLine" id="cb15-92" data-line-number="92"></a>
<a class="sourceLine" id="cb15-93" data-line-number="93">} <span class="co">// 文件已经被析构器自动关闭</span></a>
<a class="sourceLine" id="cb15-94" data-line-number="94"></a></code></pre></div>
<h1 id="杂项misc">
<span class="header-section-number">11</span> 杂项Misc</h1>
<h2 id="函数重载">
<span class="header-section-number">11.1</span> 函数重载</h2>
<p>C++支持函数重载，也就是可以定义一组名称相同而参数不同的函数。<br>
实现上类似于根据函数名+参数类型生成新的函数名。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="dt">void</span> print(<span class="dt">char</span> *myString)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    printf(<span class="st">"String </span><span class="sc">%s\n</span><span class="st">"</span>, myString);</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="dt">void</span> print(<span class="dt">int</span> myInt)</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">{</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">    printf(<span class="st">"My int is </span><span class="sc">%d</span><span class="st">"</span>, myInt);</a>
<a class="sourceLine" id="cb16-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb16-10" data-line-number="10"></a>
<a class="sourceLine" id="cb16-11" data-line-number="11"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb16-12" data-line-number="12">{</a>
<a class="sourceLine" id="cb16-13" data-line-number="13">    print(<span class="st">"Hello"</span>);</a>
<a class="sourceLine" id="cb16-14" data-line-number="14">    print(<span class="dv">15</span>);</a>
<a class="sourceLine" id="cb16-15" data-line-number="15">}</a></code></pre></div>
<h2 id="参数默认值设置">
<span class="header-section-number">11.2</span> 参数默认值设置</h2>
<p>可以为函数的参数指定默认值，在调用者没有提供相应参数时按照默认值调用。<br>
具有默认值的参数必须放在所有的常规参数之后。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="dt">void</span> doSomethingWithInts(<span class="dt">int</span> a = <span class="dv">1</span>, <span class="dt">int</span> b = <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="dt">void</span> invalidDeclaration(<span class="dt">int</span> a = <span class="dv">1</span>, <span class="dt">int</span> b) <span class="co">// 这是错误的！</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb17-7" data-line-number="7"></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb17-9" data-line-number="9"></a>
<a class="sourceLine" id="cb17-10" data-line-number="10"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">{</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">    doSomethingWithInts();      <span class="co">// a = 1,  b = 4</span></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">    doSomethingWithInts(<span class="dv">20</span>);    <span class="co">// a = 20, b = 4</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14">    doSomethingWithInts(<span class="dv">20</span>, <span class="dv">5</span>); <span class="co">// a = 20, b = 5</span></a>
<a class="sourceLine" id="cb17-15" data-line-number="15">}</a></code></pre></div>
<h2 id="空指针">
<span class="header-section-number">11.3</span> 空指针</h2>
<p>在C++中使用nullptr代替C语言中的NULL。</p>
<h2 id="严格原型">
<span class="header-section-number">11.4</span> 严格原型</h2>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co">// C++的函数原型与函数定义是严格匹配的</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="dt">void</span> func(); <span class="co">// 这个函数不能接受任何参数</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"></a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="co">// 而在C语言中</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="dt">void</span> func(); <span class="co">// 这个函数能接受任意数量的参数</span></a></code></pre></div>
<h1 id="c新特性">
<span class="header-section-number">12</span> C++新特性</h1>
<p>C++语言也在不停地发展，比如说C++11引入了许多有用的新特性，可以留意相关的博文。</p>
<h1 id="stl">
<span class="header-section-number">13</span> STL</h1>


        </article>
        
        <div class="ui horizontal grey divider header">Modified at: March 6, 2018</div>
        
        <div class="ui hidden divider"></div>
        <a href="../../../../about#reward">
          <img class="ui centered image" src="../../../../assets/images/reward.png">
        </a>
    </div>
    <div class="ui secondary segment">
        <div class="ui list">
            
            <a class="item" href="../../02/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">
                <div class="ui url blue label">« Prev</div>常见排序算法
            </a>
            
            
            <a class="item" href="../%E9%80%9A%E7%94%A8%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8spacemacs/">
                <div class="ui url blue label">» Next</div>通用代码编辑器Spacemacs
            </a>
            
        </div>
    </div>
    <div class="ui blue segment">
		
        <script>
         var idcomments_acct = 'c5bb6e189e91abf8985279b97aa3ab46';
         var idcomments_post_id;
         var idcomments_post_url;
        </script>
        <span id="IDCommentsPostTitle" style="display:none"></span>
        <script type="text/javascript" src="https://www.intensedebate.com/js/genericCommentWrapperV2.js" defer></script>
		
    </div>
    <div class="sidebar-toggle" style="display: none">
		<div class="sidebar-toggle-line-wrap">
			<span class="sidebar-toggle-line sidebar-toggle-line-first" style="top: 0px; transform: rotateZ(0deg); width: 100%; opacity: 1; left: 0px;"></span>
			<span class="sidebar-toggle-line sidebar-toggle-line-middle" style="opacity: 1; width: 100%; left: 0px; top: 0px; transform: rotateZ(0deg);"></span>
			<span class="sidebar-toggle-line sidebar-toggle-line-last" style="top: 0px; transform: rotateZ(0deg); width: 100%; opacity: 1; left: 0px;"></span>
		</div>
    </div>
    <div class="back-to-top"></div>
</div>
<script type="text/javascript">
 function genTocAtLevel(sp, dp, lvl) {
     c = sp.find('>ul>li');
     if (0 != c.length) {
         c.each(function(i,n){
             nn = $(n);
             itStr = '<div class="item"></div>';
             dp.append(itStr);

             it = dp.find('>.item:last');
             a = nn.find('>a');
             if (0 != a.length) {
                 //console.log('level: '+lvl+' item: '+a.text());
                 // clear id in case of internal links
                 a.children().attr('id', '');

                 it.append(a.first().clone());
             }
             if (0 != nn.find('>ul>li').length){
                 mnStr = '<div class="menu"></div>';
                 it.append(mnStr);
                 mn = it.find('>.menu');
                 genTocAtLevel(nn, mn, lvl+1);
             }
         });
     }
 }
</script>

                </div>
				        <div id="page-loader" class="ui centered inline loader"></div>
            </div>
            <div class="ui hidden divider placeholder"></div>

            <footer class="ui inverted vertical center aligned segment">
                <div class="ui container">
                    <script type="text/javascript">
                    document.write("<p>Copyright © 2011-xxxx by 时聆心语&nbsp;&nbsp;·&nbsp;&nbsp;Powered by Nanoc, Pandoc, Semantic UI, Travis CI, GitHub Pages, etc.</p>".replace('xxxx', new Date().getFullYear()));
                    </script>
                </div>
            </footer>   

        </div>

  

        <!-- JS Includes -->
        <script src="../../../../assets/jquery.min.js"></script>
        <script src="../../../../assets/semantic.min.js"></script>
        <script src="../../../../assets/iframeResizer.contentWindow.min.js"></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript" defer></script>
    </body>
    <script type="text/javascript">
     $(document).ready(function(){
    	   $('.page.header').visibility({
             type: 'fixed'
         });

     $('.back-to-top').on('click', function () {
        $('html,body').animate({scrollTop: 0}, 100);
     });

     $('span.header-section-number ~ span[data-tag-name]').each(function(i,n){
         nn = $(n);
         nn.text(nn.attr('data-tag-name'));
     });

         if (0 != $('#_home_page_').length) {
             hp = $('#_home_page_');
             hp.data('cur_page', 1);

		         $('.page.content > .container').visibility({
			           once: false,
			           // update size when new content loads
			           observeChanges: true,
			           // load content on bottom edge visible
			           onBottomVisible: function() {
				             $('#page-loader').addClass('visible');
					           getPaginatedArticles(hp.data('cur_page')+1);
		             }
			       });
         }

         if (0 != $('#_SRC_TOC_').length){
             $('.sidebar').sidebar({ transition: 'overlay', dimPage: false }).sidebar('toggle');

             sp = $('#_SRC_TOC_');
             dp = $('#_dst_toc_');
             genTocAtLevel(sp, dp, 1);

            $('.sidebar-toggle').show().on('click', function () {
                $('.sidebar').sidebar({ transition: 'overlay', dimPage: false }).sidebar('toggle');
            });
         }
		     $(window).bind('hashchange', function() {
			       if (location.hash) {
				         var target = $(decodeURI(location.hash));
				         if(target.length==1) {
			    	         var top = target.offset().top-$('.page.header').height();
					           if(top > 0)
					               {
					                   $('html,body').animate({scrollTop:top}, 100);
					               }
				         }
				         //location.hash = '';
				         history.replaceState("", document.title, window.location.pathname + window.location.search);
			       }
		     });
     });
    </script>
</html>
